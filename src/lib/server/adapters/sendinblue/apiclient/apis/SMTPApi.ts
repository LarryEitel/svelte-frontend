// @ts-nocheck
/* tslint:disable */
/* eslint-disable */
/**
 * SendinBlue API
 * SendinBlue provide a RESTFul API that can be used with any languages. With this API, you will be able to :   - Manage your campaigns and get the statistics   - Manage your contacts   - Send transactional Emails and SMS   - and much more...  You can download our wrappers at https://github.com/orgs/sendinblue  **Possible responses**   | Code | Message |   | :-------------: | ------------- |   | 200  | OK. Successful Request  |   | 201  | OK. Successful Creation |   | 202  | OK. Request accepted |   | 204  | OK. Successful Update/Deletion  |   | 400  | Error. Bad Request  |   | 401  | Error. Authentication Needed  |   | 402  | Error. Not enough credit, plan upgrade needed  |   | 403  | Error. Permission denied  |   | 404  | Error. Object does not exist |   | 405  | Error. Method not allowed  |   | 406  | Error. Not Acceptable  |
 *
 * The version of the OpenAPI document: 3.0.0
 * Contact: contact@sendinblue.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type {
	BlockDomain,
	CreateModel,
	CreateSmtpEmail,
	CreateSmtpTemplate,
	DeleteHardbounces,
	ErrorModel,
	GetAggregatedReport,
	GetBlockedDomains,
	GetEmailEventReport,
	GetReports,
	GetSmtpTemplateOverview,
	GetSmtpTemplates,
	GetTransacBlockedContacts,
	GetTransacEmailContent,
	GetTransacEmailsList,
	PostSendFailed,
	SendEmail,
	SendSmtpEmail,
	SendTemplateEmail,
	SendTestEmail,
	UpdateSmtpTemplate
} from '../models';
import {
	BlockDomainFromJSON,
	BlockDomainToJSON,
	CreateModelFromJSON,
	CreateModelToJSON,
	CreateSmtpEmailFromJSON,
	CreateSmtpEmailToJSON,
	CreateSmtpTemplateFromJSON,
	CreateSmtpTemplateToJSON,
	DeleteHardbouncesFromJSON,
	DeleteHardbouncesToJSON,
	ErrorModelFromJSON,
	ErrorModelToJSON,
	GetAggregatedReportFromJSON,
	GetAggregatedReportToJSON,
	GetBlockedDomainsFromJSON,
	GetBlockedDomainsToJSON,
	GetEmailEventReportFromJSON,
	GetEmailEventReportToJSON,
	GetReportsFromJSON,
	GetReportsToJSON,
	GetSmtpTemplateOverviewFromJSON,
	GetSmtpTemplateOverviewToJSON,
	GetSmtpTemplatesFromJSON,
	GetSmtpTemplatesToJSON,
	GetTransacBlockedContactsFromJSON,
	GetTransacBlockedContactsToJSON,
	GetTransacEmailContentFromJSON,
	GetTransacEmailContentToJSON,
	GetTransacEmailsListFromJSON,
	GetTransacEmailsListToJSON,
	PostSendFailedFromJSON,
	PostSendFailedToJSON,
	SendEmailFromJSON,
	SendEmailToJSON,
	SendSmtpEmailFromJSON,
	SendSmtpEmailToJSON,
	SendTemplateEmailFromJSON,
	SendTemplateEmailToJSON,
	SendTestEmailFromJSON,
	SendTestEmailToJSON,
	UpdateSmtpTemplateFromJSON,
	UpdateSmtpTemplateToJSON
} from '../models';

export interface BlockNewDomainRequest {
	blockDomain: BlockDomain;
}

export interface CreateSmtpTemplateRequest {
	smtpTemplate: CreateSmtpTemplate;
}

export interface DeleteBlockedDomainRequest {
	domain: string;
}

export interface DeleteHardbouncesRequest {
	deleteHardbounces?: DeleteHardbounces;
}

export interface DeleteSmtpTemplateRequest {
	templateId: number;
}

export interface GetAggregatedSmtpReportRequest {
	startDate?: string;
	endDate?: string;
	days?: number;
	tag?: string;
}

export interface GetEmailEventReportRequest {
	limit?: number;
	offset?: number;
	startDate?: string;
	endDate?: string;
	days?: number;
	email?: string;
	event?: GetEmailEventReportEventEnum;
	tags?: string;
	messageId?: string;
	templateId?: number;
}

export interface GetSmtpReportRequest {
	limit?: number;
	offset?: number;
	startDate?: string;
	endDate?: string;
	days?: number;
	tag?: string;
}

export interface GetSmtpTemplateRequest {
	templateId: number;
}

export interface GetSmtpTemplatesRequest {
	templateStatus?: boolean;
	limit?: number;
	offset?: number;
}

export interface GetTransacBlockedContactsRequest {
	startDate?: string;
	endDate?: string;
	limit?: number;
	offset?: number;
	senders?: Array<string>;
}

export interface GetTransacEmailContentRequest {
	uuid: string;
}

export interface GetTransacEmailsListRequest {
	email?: string;
	templateId?: number;
	messageId?: string;
	startDate?: Date;
	endDate?: Date;
}

export interface SendTemplateRequest {
	templateId: number;
	sendEmail: SendEmail;
}

export interface SendTestTemplateRequest {
	templateId: number;
	sendTestEmail: SendTestEmail;
}

export interface SendTransacEmailRequest {
	sendSmtpEmail: SendSmtpEmail;
}

export interface SmtpBlockedContactsEmailDeleteRequest {
	email: string;
}

export interface SmtpLogMessageIdDeleteRequest {
	messageId: string;
}

export interface UpdateSmtpTemplateRequest {
	templateId: number;
	smtpTemplate: UpdateSmtpTemplate;
}

/**
 *
 */
export class SMTPApi extends runtime.BaseAPI {
	/**
	 * Blocks a new domain in order to avoid messages being sent to the same
	 * Add a new domain to the list of blocked domains
	 */
	async blockNewDomainRaw(
		requestParameters: BlockNewDomainRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.blockDomain === null || requestParameters.blockDomain === undefined) {
			throw new runtime.RequiredError(
				'blockDomain',
				'Required parameter requestParameters.blockDomain was null or undefined when calling blockNewDomain.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters['Content-Type'] = 'application/json';

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['api-key'] = this.configuration.apiKey('api-key'); // api-key authentication
		}

		const response = await this.request(
			{
				path: `/smtp/blockedDomains`,
				method: 'POST',
				headers: headerParameters,
				query: queryParameters,
				body: BlockDomainToJSON(requestParameters.blockDomain)
			},
			initOverrides
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Blocks a new domain in order to avoid messages being sent to the same
	 * Add a new domain to the list of blocked domains
	 */
	async blockNewDomain(
		requestParameters: BlockNewDomainRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<void> {
		await this.blockNewDomainRaw(requestParameters, initOverrides);
	}

	/**
	 * Create an email template
	 */
	async createSmtpTemplateRaw(
		requestParameters: CreateSmtpTemplateRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<CreateModel>> {
		if (requestParameters.smtpTemplate === null || requestParameters.smtpTemplate === undefined) {
			throw new runtime.RequiredError(
				'smtpTemplate',
				'Required parameter requestParameters.smtpTemplate was null or undefined when calling createSmtpTemplate.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters['Content-Type'] = 'application/json';

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['api-key'] = this.configuration.apiKey('api-key'); // api-key authentication
		}

		const response = await this.request(
			{
				path: `/smtp/templates`,
				method: 'POST',
				headers: headerParameters,
				query: queryParameters,
				body: CreateSmtpTemplateToJSON(requestParameters.smtpTemplate)
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => CreateModelFromJSON(jsonValue));
	}

	/**
	 * Create an email template
	 */
	async createSmtpTemplate(
		requestParameters: CreateSmtpTemplateRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<CreateModel> {
		const response = await this.createSmtpTemplateRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Unblocks an existing domain from the list of blocked domains
	 * Unblock an existing domain from the list of blocked domains
	 */
	async deleteBlockedDomainRaw(
		requestParameters: DeleteBlockedDomainRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.domain === null || requestParameters.domain === undefined) {
			throw new runtime.RequiredError(
				'domain',
				'Required parameter requestParameters.domain was null or undefined when calling deleteBlockedDomain.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['api-key'] = this.configuration.apiKey('api-key'); // api-key authentication
		}

		const response = await this.request(
			{
				path: `/smtp/blockedDomains/{domain}`.replace(
					`{${'domain'}}`,
					encodeURIComponent(String(requestParameters.domain))
				),
				method: 'DELETE',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Unblocks an existing domain from the list of blocked domains
	 * Unblock an existing domain from the list of blocked domains
	 */
	async deleteBlockedDomain(
		requestParameters: DeleteBlockedDomainRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<void> {
		await this.deleteBlockedDomainRaw(requestParameters, initOverrides);
	}

	/**
	 * Delete hardbounces. To use carefully (e.g. in case of temporary ISP failures)
	 * Delete hardbounces
	 */
	async deleteHardbouncesRaw(
		requestParameters: DeleteHardbouncesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<void>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters['Content-Type'] = 'application/json';

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['api-key'] = this.configuration.apiKey('api-key'); // api-key authentication
		}

		const response = await this.request(
			{
				path: `/smtp/deleteHardbounces`,
				method: 'POST',
				headers: headerParameters,
				query: queryParameters,
				body: DeleteHardbouncesToJSON(requestParameters.deleteHardbounces)
			},
			initOverrides
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Delete hardbounces. To use carefully (e.g. in case of temporary ISP failures)
	 * Delete hardbounces
	 */
	async deleteHardbounces(
		requestParameters: DeleteHardbouncesRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<void> {
		await this.deleteHardbouncesRaw(requestParameters, initOverrides);
	}

	/**
	 * Delete an inactive email template
	 */
	async deleteSmtpTemplateRaw(
		requestParameters: DeleteSmtpTemplateRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.templateId === null || requestParameters.templateId === undefined) {
			throw new runtime.RequiredError(
				'templateId',
				'Required parameter requestParameters.templateId was null or undefined when calling deleteSmtpTemplate.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['api-key'] = this.configuration.apiKey('api-key'); // api-key authentication
		}

		const response = await this.request(
			{
				path: `/smtp/templates/{templateId}`.replace(
					`{${'templateId'}}`,
					encodeURIComponent(String(requestParameters.templateId))
				),
				method: 'DELETE',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Delete an inactive email template
	 */
	async deleteSmtpTemplate(
		requestParameters: DeleteSmtpTemplateRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<void> {
		await this.deleteSmtpTemplateRaw(requestParameters, initOverrides);
	}

	/**
	 * Get your transactional email activity aggregated over a period of time
	 */
	async getAggregatedSmtpReportRaw(
		requestParameters: GetAggregatedSmtpReportRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<GetAggregatedReport>> {
		const queryParameters: any = {};

		if (requestParameters.startDate !== undefined) {
			queryParameters['startDate'] = requestParameters.startDate;
		}

		if (requestParameters.endDate !== undefined) {
			queryParameters['endDate'] = requestParameters.endDate;
		}

		if (requestParameters.days !== undefined) {
			queryParameters['days'] = requestParameters.days;
		}

		if (requestParameters.tag !== undefined) {
			queryParameters['tag'] = requestParameters.tag;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['api-key'] = this.configuration.apiKey('api-key'); // api-key authentication
		}

		const response = await this.request(
			{
				path: `/smtp/statistics/aggregatedReport`,
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GetAggregatedReportFromJSON(jsonValue)
		);
	}

	/**
	 * Get your transactional email activity aggregated over a period of time
	 */
	async getAggregatedSmtpReport(
		requestParameters: GetAggregatedSmtpReportRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<GetAggregatedReport> {
		const response = await this.getAggregatedSmtpReportRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Get the list of blocked domains
	 * Get the list of blocked domains
	 */
	async getBlockedDomainsRaw(
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<GetBlockedDomains>> {
		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['api-key'] = this.configuration.apiKey('api-key'); // api-key authentication
		}

		const response = await this.request(
			{
				path: `/smtp/blockedDomains`,
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GetBlockedDomainsFromJSON(jsonValue)
		);
	}

	/**
	 * Get the list of blocked domains
	 * Get the list of blocked domains
	 */
	async getBlockedDomains(
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<GetBlockedDomains> {
		const response = await this.getBlockedDomainsRaw(initOverrides);
		return await response.value();
	}

	/**
	 * Get all your transactional email activity (unaggregated events)
	 */
	async getEmailEventReportRaw(
		requestParameters: GetEmailEventReportRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<GetEmailEventReport>> {
		const queryParameters: any = {};

		if (requestParameters.limit !== undefined) {
			queryParameters['limit'] = requestParameters.limit;
		}

		if (requestParameters.offset !== undefined) {
			queryParameters['offset'] = requestParameters.offset;
		}

		if (requestParameters.startDate !== undefined) {
			queryParameters['startDate'] = requestParameters.startDate;
		}

		if (requestParameters.endDate !== undefined) {
			queryParameters['endDate'] = requestParameters.endDate;
		}

		if (requestParameters.days !== undefined) {
			queryParameters['days'] = requestParameters.days;
		}

		if (requestParameters.email !== undefined) {
			queryParameters['email'] = requestParameters.email;
		}

		if (requestParameters.event !== undefined) {
			queryParameters['event'] = requestParameters.event;
		}

		if (requestParameters.tags !== undefined) {
			queryParameters['tags'] = requestParameters.tags;
		}

		if (requestParameters.messageId !== undefined) {
			queryParameters['messageId'] = requestParameters.messageId;
		}

		if (requestParameters.templateId !== undefined) {
			queryParameters['templateId'] = requestParameters.templateId;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['api-key'] = this.configuration.apiKey('api-key'); // api-key authentication
		}

		const response = await this.request(
			{
				path: `/smtp/statistics/events`,
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GetEmailEventReportFromJSON(jsonValue)
		);
	}

	/**
	 * Get all your transactional email activity (unaggregated events)
	 */
	async getEmailEventReport(
		requestParameters: GetEmailEventReportRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<GetEmailEventReport> {
		const response = await this.getEmailEventReportRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Get your transactional email activity aggregated per day
	 */
	async getSmtpReportRaw(
		requestParameters: GetSmtpReportRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<GetReports>> {
		const queryParameters: any = {};

		if (requestParameters.limit !== undefined) {
			queryParameters['limit'] = requestParameters.limit;
		}

		if (requestParameters.offset !== undefined) {
			queryParameters['offset'] = requestParameters.offset;
		}

		if (requestParameters.startDate !== undefined) {
			queryParameters['startDate'] = requestParameters.startDate;
		}

		if (requestParameters.endDate !== undefined) {
			queryParameters['endDate'] = requestParameters.endDate;
		}

		if (requestParameters.days !== undefined) {
			queryParameters['days'] = requestParameters.days;
		}

		if (requestParameters.tag !== undefined) {
			queryParameters['tag'] = requestParameters.tag;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['api-key'] = this.configuration.apiKey('api-key'); // api-key authentication
		}

		const response = await this.request(
			{
				path: `/smtp/statistics/reports`,
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => GetReportsFromJSON(jsonValue));
	}

	/**
	 * Get your transactional email activity aggregated per day
	 */
	async getSmtpReport(
		requestParameters: GetSmtpReportRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<GetReports> {
		const response = await this.getSmtpReportRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Returns the template information
	 */
	async getSmtpTemplateRaw(
		requestParameters: GetSmtpTemplateRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<GetSmtpTemplateOverview>> {
		if (requestParameters.templateId === null || requestParameters.templateId === undefined) {
			throw new runtime.RequiredError(
				'templateId',
				'Required parameter requestParameters.templateId was null or undefined when calling getSmtpTemplate.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['api-key'] = this.configuration.apiKey('api-key'); // api-key authentication
		}

		const response = await this.request(
			{
				path: `/smtp/templates/{templateId}`.replace(
					`{${'templateId'}}`,
					encodeURIComponent(String(requestParameters.templateId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GetSmtpTemplateOverviewFromJSON(jsonValue)
		);
	}

	/**
	 * Returns the template information
	 */
	async getSmtpTemplate(
		requestParameters: GetSmtpTemplateRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<GetSmtpTemplateOverview> {
		const response = await this.getSmtpTemplateRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Get the list of email templates
	 */
	async getSmtpTemplatesRaw(
		requestParameters: GetSmtpTemplatesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<GetSmtpTemplates>> {
		const queryParameters: any = {};

		if (requestParameters.templateStatus !== undefined) {
			queryParameters['templateStatus'] = requestParameters.templateStatus;
		}

		if (requestParameters.limit !== undefined) {
			queryParameters['limit'] = requestParameters.limit;
		}

		if (requestParameters.offset !== undefined) {
			queryParameters['offset'] = requestParameters.offset;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['api-key'] = this.configuration.apiKey('api-key'); // api-key authentication
		}

		const response = await this.request(
			{
				path: `/smtp/templates`,
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GetSmtpTemplatesFromJSON(jsonValue)
		);
	}

	/**
	 * Get the list of email templates
	 */
	async getSmtpTemplates(
		requestParameters: GetSmtpTemplatesRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<GetSmtpTemplates> {
		const response = await this.getSmtpTemplatesRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Get the list of blocked or unsubscribed transactional contacts
	 */
	async getTransacBlockedContactsRaw(
		requestParameters: GetTransacBlockedContactsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<GetTransacBlockedContacts>> {
		const queryParameters: any = {};

		if (requestParameters.startDate !== undefined) {
			queryParameters['startDate'] = requestParameters.startDate;
		}

		if (requestParameters.endDate !== undefined) {
			queryParameters['endDate'] = requestParameters.endDate;
		}

		if (requestParameters.limit !== undefined) {
			queryParameters['limit'] = requestParameters.limit;
		}

		if (requestParameters.offset !== undefined) {
			queryParameters['offset'] = requestParameters.offset;
		}

		if (requestParameters.senders) {
			queryParameters['senders'] = requestParameters.senders.join(
				runtime.COLLECTION_FORMATS['csv']
			);
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['api-key'] = this.configuration.apiKey('api-key'); // api-key authentication
		}

		const response = await this.request(
			{
				path: `/smtp/blockedContacts`,
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GetTransacBlockedContactsFromJSON(jsonValue)
		);
	}

	/**
	 * Get the list of blocked or unsubscribed transactional contacts
	 */
	async getTransacBlockedContacts(
		requestParameters: GetTransacBlockedContactsRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<GetTransacBlockedContacts> {
		const response = await this.getTransacBlockedContactsRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Get the personalized content of a sent transactional email
	 */
	async getTransacEmailContentRaw(
		requestParameters: GetTransacEmailContentRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<GetTransacEmailContent>> {
		if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
			throw new runtime.RequiredError(
				'uuid',
				'Required parameter requestParameters.uuid was null or undefined when calling getTransacEmailContent.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['api-key'] = this.configuration.apiKey('api-key'); // api-key authentication
		}

		const response = await this.request(
			{
				path: `/smtp/emails/{uuid}`.replace(
					`{${'uuid'}}`,
					encodeURIComponent(String(requestParameters.uuid))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GetTransacEmailContentFromJSON(jsonValue)
		);
	}

	/**
	 * Get the personalized content of a sent transactional email
	 */
	async getTransacEmailContent(
		requestParameters: GetTransacEmailContentRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<GetTransacEmailContent> {
		const response = await this.getTransacEmailContentRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * This endpoint will show the list of emails for past 30 days by default. To retrieve emails before that time, please pass startDate and endDate in query filters.
	 * Get the list of transactional emails on the basis of allowed filters
	 */
	async getTransacEmailsListRaw(
		requestParameters: GetTransacEmailsListRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<GetTransacEmailsList>> {
		const queryParameters: any = {};

		if (requestParameters.email !== undefined) {
			queryParameters['email'] = requestParameters.email;
		}

		if (requestParameters.templateId !== undefined) {
			queryParameters['templateId'] = requestParameters.templateId;
		}

		if (requestParameters.messageId !== undefined) {
			queryParameters['messageId'] = requestParameters.messageId;
		}

		if (requestParameters.startDate !== undefined) {
			queryParameters['startDate'] = (requestParameters.startDate as any)
				.toISOString()
				.substr(0, 10);
		}

		if (requestParameters.endDate !== undefined) {
			queryParameters['endDate'] = (requestParameters.endDate as any).toISOString().substr(0, 10);
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['api-key'] = this.configuration.apiKey('api-key'); // api-key authentication
		}

		const response = await this.request(
			{
				path: `/smtp/emails`,
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			GetTransacEmailsListFromJSON(jsonValue)
		);
	}

	/**
	 * This endpoint will show the list of emails for past 30 days by default. To retrieve emails before that time, please pass startDate and endDate in query filters.
	 * Get the list of transactional emails on the basis of allowed filters
	 */
	async getTransacEmailsList(
		requestParameters: GetTransacEmailsListRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<GetTransacEmailsList> {
		const response = await this.getTransacEmailsListRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * This endpoint is deprecated. Prefer v3/smtp/email instead.
	 * Send a template
	 */
	async sendTemplateRaw(
		requestParameters: SendTemplateRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<SendTemplateEmail>> {
		if (requestParameters.templateId === null || requestParameters.templateId === undefined) {
			throw new runtime.RequiredError(
				'templateId',
				'Required parameter requestParameters.templateId was null or undefined when calling sendTemplate.'
			);
		}

		if (requestParameters.sendEmail === null || requestParameters.sendEmail === undefined) {
			throw new runtime.RequiredError(
				'sendEmail',
				'Required parameter requestParameters.sendEmail was null or undefined when calling sendTemplate.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters['Content-Type'] = 'application/json';

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['api-key'] = this.configuration.apiKey('api-key'); // api-key authentication
		}

		const response = await this.request(
			{
				path: `/smtp/templates/{templateId}/send`.replace(
					`{${'templateId'}}`,
					encodeURIComponent(String(requestParameters.templateId))
				),
				method: 'POST',
				headers: headerParameters,
				query: queryParameters,
				body: SendEmailToJSON(requestParameters.sendEmail)
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			SendTemplateEmailFromJSON(jsonValue)
		);
	}

	/**
	 * This endpoint is deprecated. Prefer v3/smtp/email instead.
	 * Send a template
	 */
	async sendTemplate(
		requestParameters: SendTemplateRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<SendTemplateEmail> {
		const response = await this.sendTemplateRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Send a template to your test list
	 */
	async sendTestTemplateRaw(
		requestParameters: SendTestTemplateRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.templateId === null || requestParameters.templateId === undefined) {
			throw new runtime.RequiredError(
				'templateId',
				'Required parameter requestParameters.templateId was null or undefined when calling sendTestTemplate.'
			);
		}

		if (requestParameters.sendTestEmail === null || requestParameters.sendTestEmail === undefined) {
			throw new runtime.RequiredError(
				'sendTestEmail',
				'Required parameter requestParameters.sendTestEmail was null or undefined when calling sendTestTemplate.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters['Content-Type'] = 'application/json';

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['api-key'] = this.configuration.apiKey('api-key'); // api-key authentication
		}

		const response = await this.request(
			{
				path: `/smtp/templates/{templateId}/sendTest`.replace(
					`{${'templateId'}}`,
					encodeURIComponent(String(requestParameters.templateId))
				),
				method: 'POST',
				headers: headerParameters,
				query: queryParameters,
				body: SendTestEmailToJSON(requestParameters.sendTestEmail)
			},
			initOverrides
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Send a template to your test list
	 */
	async sendTestTemplate(
		requestParameters: SendTestTemplateRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<void> {
		await this.sendTestTemplateRaw(requestParameters, initOverrides);
	}

	/**
	 * Send a transactional email
	 */
	async sendTransacEmailRaw(
		requestParameters: SendTransacEmailRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<CreateSmtpEmail>> {
		if (requestParameters.sendSmtpEmail === null || requestParameters.sendSmtpEmail === undefined) {
			throw new runtime.RequiredError(
				'sendSmtpEmail',
				'Required parameter requestParameters.sendSmtpEmail was null or undefined when calling sendTransacEmail.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters['Content-Type'] = 'application/json';

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['api-key'] = this.configuration.apiKey('api-key'); // api-key authentication
		}

		const response = await this.request(
			{
				path: `/smtp/email`,
				method: 'POST',
				headers: headerParameters,
				query: queryParameters,
				body: SendSmtpEmailToJSON(requestParameters.sendSmtpEmail)
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => CreateSmtpEmailFromJSON(jsonValue));
	}

	/**
	 * Send a transactional email
	 */
	async sendTransacEmail(
		requestParameters: SendTransacEmailRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<CreateSmtpEmail> {
		const response = await this.sendTransacEmailRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Unblock or resubscribe a transactional contact
	 */
	async smtpBlockedContactsEmailDeleteRaw(
		requestParameters: SmtpBlockedContactsEmailDeleteRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.email === null || requestParameters.email === undefined) {
			throw new runtime.RequiredError(
				'email',
				'Required parameter requestParameters.email was null or undefined when calling smtpBlockedContactsEmailDelete.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['api-key'] = this.configuration.apiKey('api-key'); // api-key authentication
		}

		const response = await this.request(
			{
				path: `/smtp/blockedContacts/{email}`.replace(
					`{${'email'}}`,
					encodeURIComponent(String(requestParameters.email))
				),
				method: 'DELETE',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Unblock or resubscribe a transactional contact
	 */
	async smtpBlockedContactsEmailDelete(
		requestParameters: SmtpBlockedContactsEmailDeleteRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<void> {
		await this.smtpBlockedContactsEmailDeleteRaw(requestParameters, initOverrides);
	}

	/**
	 * Delete an SMTP transactional log
	 */
	async smtpLogMessageIdDeleteRaw(
		requestParameters: SmtpLogMessageIdDeleteRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.messageId === null || requestParameters.messageId === undefined) {
			throw new runtime.RequiredError(
				'messageId',
				'Required parameter requestParameters.messageId was null or undefined when calling smtpLogMessageIdDelete.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['api-key'] = this.configuration.apiKey('api-key'); // api-key authentication
		}

		const response = await this.request(
			{
				path: `/smtp/log/{messageId}`.replace(
					`{${'messageId'}}`,
					encodeURIComponent(String(requestParameters.messageId))
				),
				method: 'DELETE',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Delete an SMTP transactional log
	 */
	async smtpLogMessageIdDelete(
		requestParameters: SmtpLogMessageIdDeleteRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<void> {
		await this.smtpLogMessageIdDeleteRaw(requestParameters, initOverrides);
	}

	/**
	 * Update an email template
	 */
	async updateSmtpTemplateRaw(
		requestParameters: UpdateSmtpTemplateRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.templateId === null || requestParameters.templateId === undefined) {
			throw new runtime.RequiredError(
				'templateId',
				'Required parameter requestParameters.templateId was null or undefined when calling updateSmtpTemplate.'
			);
		}

		if (requestParameters.smtpTemplate === null || requestParameters.smtpTemplate === undefined) {
			throw new runtime.RequiredError(
				'smtpTemplate',
				'Required parameter requestParameters.smtpTemplate was null or undefined when calling updateSmtpTemplate.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters['Content-Type'] = 'application/json';

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['api-key'] = this.configuration.apiKey('api-key'); // api-key authentication
		}

		const response = await this.request(
			{
				path: `/smtp/templates/{templateId}`.replace(
					`{${'templateId'}}`,
					encodeURIComponent(String(requestParameters.templateId))
				),
				method: 'PUT',
				headers: headerParameters,
				query: queryParameters,
				body: UpdateSmtpTemplateToJSON(requestParameters.smtpTemplate)
			},
			initOverrides
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Update an email template
	 */
	async updateSmtpTemplate(
		requestParameters: UpdateSmtpTemplateRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<void> {
		await this.updateSmtpTemplateRaw(requestParameters, initOverrides);
	}
}

/**
 * @export
 * @enum {string}
 */
export enum GetEmailEventReportEventEnum {
	Bounces = 'bounces',
	HardBounces = 'hardBounces',
	SoftBounces = 'softBounces',
	Delivered = 'delivered',
	Spam = 'spam',
	Requests = 'requests',
	Opened = 'opened',
	Clicks = 'clicks',
	Invalid = 'invalid',
	Deferred = 'deferred',
	Blocked = 'blocked',
	Unsubscribed = 'unsubscribed'
}
